<!doctype html>
<html lang="en">
<meta charset="utf-8">
<head>
  <link rel="stylesheet" type="text/css" href="3rdparty/markdown.css">
<link rel="stylesheet" href="3rdparty/github.css">
<script src="3rdparty/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
  <script src="3rdparty/marked.min.js"></script>
</head>
<body>
  <div id="placeholder"></div>
  <script>
  'use strict';

  var placeholder = document.getElementById('placeholder');

  var updateText = function(text) {
  marked.setOptions({
        highlight: function (code) {
        return hljs.highlightAuto(code).value;
      }
    });
      placeholder.innerHTML = marked(text);
  }

  updateText('# 滑动条\n\n## [1、滑动条点击定位](滑动条点击定位.py)\n\n1. `QSlider`对鼠标点击然后跳转到该位置的支持不是很好，通过重写鼠标点击事件`mousePressEvent`来达到效果\n1. 通过`style`的`subControlRect`方法计算得到滑块的区域，当鼠标点击区域在此次时则交给系统自己处理（比如按住不放拖动）\n1. 通过`orientation`判断滑动条的方向（横竖）\n1. 通过`invertedAppearance`判断滑动条是否反向（左右、上下）\n\n核心代码：\n\n```python\ndef mousePressEvent(self, event):\n    # 获取上面的拉动块位置\n    option = QStyleOptionSlider()\n    self.initStyleOption(option)\n    rect = self.style().subControlRect(\n        QStyle.CC_Slider, option, QStyle.SC_SliderHandle, self)\n    if rect.contains(event.pos()):\n        # 如果鼠标点击的位置在滑块上则交给Qt自行处理\n        super(JumpSlider, self).mousePressEvent(event)\n        return\n    if self.orientation() == Qt.Horizontal:\n        # 横向，要考虑invertedAppearance是否反向显示的问题\n        self.setValue(self.style().sliderValueFromPosition(\n            self.minimum(), self.maximum(),\n            event.x() if not self.invertedAppearance() else (self.width(\n            ) - event.x()), self.width()))\n    else:\n        # 纵向\n        self.setValue(self.style().sliderValueFromPosition(\n            self.minimum(), self.maximum(),\n            (self.height() - event.y()) if not self.invertedAppearance(\n            ) else event.y(), self.height()))\n```\n\n![截图](ScreenShot/滑动条点击定位.gif)');
  </script>
</body>
</html>



